<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Pickleball Line Review</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a2e;
            color: white;
            min-height: 100vh;
            overflow: hidden;
            touch-action: manipulation;
        }

        .app-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            height: 100dvh;
        }

        /* ========== HEADER ========== */
        .header {
            background: linear-gradient(135deg, #16213e 0%, #1a1a2e 100%);
            padding: 8px 12px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-bottom: 1px solid #333;
            flex-shrink: 0;
        }

        .header h1 {
            font-size: 16px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .header h1::before {
            content: "üèì";
        }

        .header-right {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .recording-indicator {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 11px;
            color: #888;
        }

        .recording-indicator.active {
            color: #ff4757;
        }

        .recording-indicator.active::before {
            content: "";
            width: 8px;
            height: 8px;
            background: #ff4757;
            border-radius: 50%;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.4; }
        }

        .fullscreen-btn {
            background: rgba(255,255,255,0.1);
            border: 1px solid #444;
            color: white;
            padding: 6px 10px;
            border-radius: 6px;
            font-size: 14px;
            cursor: pointer;
        }

        /* ========== VIDEO CONTAINER ========== */
        .video-container {
            flex: 1;
            position: relative;
            background: #000;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            min-height: 0;
        }

        #liveVideo {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        #reviewCanvas {
            max-width: 100%;
            max-height: 100%;
            width: auto;
            height: auto;
            display: none;
            object-fit: contain;
            background: #000;
        }

        /* ========== CROP OVERLAY ========== */
        .crop-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            display: none;
        }

        .crop-overlay.visible {
            display: block;
        }

        .crop-region {
            position: absolute;
            border: 3px solid #00ff88;
            background: transparent;
            box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.6);
            pointer-events: auto;
            cursor: move;
            touch-action: none;
        }

        .crop-handle {
            position: absolute;
            width: 30px;
            height: 30px;
            background: #00ff88;
            border-radius: 50%;
            pointer-events: auto;
            touch-action: none;
        }

        .crop-handle.top-left { top: -15px; left: -15px; cursor: nwse-resize; }
        .crop-handle.top-right { top: -15px; right: -15px; cursor: nesw-resize; }
        .crop-handle.bottom-left { bottom: -15px; left: -15px; cursor: nesw-resize; }
        .crop-handle.bottom-right { bottom: -15px; right: -15px; cursor: nwse-resize; }

        .crop-label {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: #00ff88;
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            white-space: nowrap;
            pointer-events: none;
        }

        .crop-instructions {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 12px 20px;
            border-radius: 10px;
            font-size: 14px;
            text-align: center;
            max-width: 90%;
            pointer-events: none;
        }

        /* ========== INFO BADGES ========== */
        .overlay-info {
            position: absolute;
            top: 8px;
            left: 8px;
            display: flex;
            flex-direction: column;
            gap: 6px;
            z-index: 10;
        }

        .info-badge {
            background: rgba(0, 0, 0, 0.75);
            padding: 4px 10px;
            border-radius: 5px;
            font-size: 12px;
            backdrop-filter: blur(4px);
        }

        .info-badge.recording { color: #00ff88; }
        .info-badge.review { color: #ffa502; }
        .info-badge.crop-mode { color: #00ff88; background: rgba(0, 255, 136, 0.2); }

        .time-badge {
            position: absolute;
            bottom: 8px;
            right: 8px;
            background: rgba(0, 0, 0, 0.75);
            padding: 6px 10px;
            border-radius: 6px;
            font-family: 'SF Mono', Monaco, 'Courier New', monospace;
            font-size: 14px;
            backdrop-filter: blur(4px);
            z-index: 10;
        }

        .buffer-badge {
            position: absolute;
            top: 8px;
            right: 8px;
            background: rgba(0, 0, 0, 0.75);
            padding: 4px 10px;
            border-radius: 5px;
            font-size: 11px;
            backdrop-filter: blur(4px);
            z-index: 10;
        }

        .buffer-badge span {
            color: #00ff88;
            font-weight: 600;
        }

        /* ========== SCRUBBER SLIDER ========== */
        .scrubber-wrap {
            margin-bottom: 10px;
        }

        .scrubber-slider {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 32px;
            background: transparent;
            outline: none;
            cursor: pointer;
            padding: 10px 0;
        }

        .scrubber-slider::-webkit-slider-runnable-track {
            width: 100%;
            height: 8px;
            background: linear-gradient(to right, #ffa502 0%, #ffa502 var(--progress, 0%), #333 var(--progress, 0%), #333 100%);
            border-radius: 4px;
        }

        .scrubber-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 28px;
            height: 28px;
            background: #fff;
            border-radius: 50%;
            cursor: pointer;
            margin-top: -10px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.4);
        }

        .scrubber-slider::-moz-range-track {
            width: 100%;
            height: 8px;
            background: #333;
            border-radius: 4px;
        }

        .scrubber-slider::-moz-range-progress {
            background: #ffa502;
            height: 8px;
            border-radius: 4px;
        }

        .scrubber-slider::-moz-range-thumb {
            width: 28px;
            height: 28px;
            background: #fff;
            border-radius: 50%;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 8px rgba(0,0,0,0.4);
        }

        /* ========== STATUS OVERLAY ========== */
        .status-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }

        .status-overlay.hidden { display: none; }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid #333;
            border-top-color: #ffa502;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            margin-bottom: 12px;
        }

        @keyframes spin { to { transform: rotate(360deg); } }

        .status-text { font-size: 14px; color: #ccc; }

        .error-box {
            background: rgba(255, 71, 87, 0.15);
            border: 1px solid #ff4757;
            border-radius: 12px;
            padding: 16px;
            max-width: 300px;
            text-align: center;
        }

        .error-box h3 { color: #ff4757; margin-bottom: 8px; }
        .error-box p { font-size: 13px; color: #aaa; }

        /* ========== CONTROLS ========== */
        .controls {
            background: linear-gradient(180deg, #16213e 0%, #0f0f1a 100%);
            padding: 10px 12px;
            padding-bottom: max(10px, env(safe-area-inset-bottom));
            flex-shrink: 0;
        }

        .mode-label {
            text-align: center;
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            margin-bottom: 8px;
            font-weight: 600;
        }

        .mode-label.live { color: #00ff88; }
        .mode-label.review { color: #ffa502; }
        .mode-label.crop { color: #00ff88; }

        .camera-row {
            display: flex;
            gap: 8px;
            margin-bottom: 10px;
        }

        .camera-select {
            flex: 1;
            padding: 10px;
            border: 1px solid #333;
            border-radius: 8px;
            background: #1a1a2e;
            color: white;
            font-size: 13px;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' fill='%23888' viewBox='0 0 16 16'%3E%3Cpath d='M8 11L3 6h10l-5 5z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 10px center;
        }

        .crop-toggle-btn {
            padding: 10px 14px;
            border: 1px solid #00ff88;
            border-radius: 8px;
            background: transparent;
            color: #00ff88;
            font-size: 13px;
            cursor: pointer;
        }

        .crop-toggle-btn.active {
            background: #00ff88;
            color: #000;
        }

        .primary-btn {
            width: 100%;
            padding: 14px;
            border: none;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .primary-btn:active { transform: scale(0.97); }

        .review-btn {
            background: linear-gradient(135deg, #ffa502 0%, #ff6348 100%);
            color: white;
        }

        .back-btn {
            background: linear-gradient(135deg, #00ff88 0%, #00b894 100%);
            color: #000;
        }

        .confirm-crop-btn {
            background: linear-gradient(135deg, #00ff88 0%, #00b894 100%);
            color: #000;
        }

        .live-controls { display: block; }
        .review-controls { display: none; }
        .crop-controls { display: none; }
        .review-controls.active { display: block; }
        .crop-controls.active { display: block; }
        .live-controls.hidden { display: none; }

        .control-grid {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 8px;
            margin-bottom: 10px;
        }

        .ctrl-btn {
            padding: 10px 6px;
            border: none;
            border-radius: 10px;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
        }

        .ctrl-btn:active { transform: scale(0.95); }
        .ctrl-btn .icon { font-size: 18px; }
        .ctrl-btn.rewind { background: #2d3436; color: white; }
        .ctrl-btn.play { background: #00b894; color: white; }
        .ctrl-btn.play.paused { background: #fdcb6e; color: #000; }
        .ctrl-btn.forward { background: #2d3436; color: white; }

        .speed-row {
            display: flex;
            gap: 6px;
            margin-bottom: 10px;
        }

        .speed-btn {
            flex: 1;
            padding: 10px 4px;
            border: 2px solid #333;
            border-radius: 8px;
            background: transparent;
            color: #666;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
        }

        .speed-btn.active {
            border-color: #ffa502;
            background: rgba(255, 165, 2, 0.15);
            color: #ffa502;
        }

        .frame-row {
            display: flex;
            gap: 6px;
            margin-bottom: 10px;
        }

        .frame-btn {
            flex: 1;
            padding: 10px;
            border: 1px solid #444;
            border-radius: 8px;
            background: #1a1a2e;
            color: #aaa;
            font-size: 12px;
            cursor: pointer;
        }

        .progress-time {
            display: flex;
            justify-content: space-between;
            font-size: 10px;
            color: #666;
            margin-top: 4px;
            font-family: 'SF Mono', Monaco, monospace;
        }

        /* ========== EXIT FULLSCREEN ========== */
        .exit-fullscreen-btn {
            position: absolute;
            top: 12px;
            right: 12px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid #555;
            color: white;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 14px;
            cursor: pointer;
            z-index: 50;
            display: none;
        }

        .app-container.fullscreen-mode .exit-fullscreen-btn {
            display: block;
        }

        .app-container.fullscreen-mode .header,
        .app-container.fullscreen-mode .controls {
            display: none !important;
        }

        /* Fullscreen review controls */
        .fullscreen-review-controls {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(transparent, rgba(0,0,0,0.8));
            padding: 60px 16px 16px;
            display: none;
            z-index: 30;
        }

        .app-container.fullscreen-mode.review-active .fullscreen-review-controls {
            display: block;
        }

        .fs-control-row {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-bottom: 12px;
        }

        .fs-btn {
            background: rgba(255,255,255,0.15);
            border: none;
            color: white;
            padding: 12px 20px;
            border-radius: 10px;
            font-size: 16px;
            cursor: pointer;
        }

        .fs-btn.play-btn { background: #00b894; padding: 12px 30px; }
        .fs-btn.play-btn.paused { background: #fdcb6e; color: #000; }

        .fs-speed-row {
            display: flex;
            gap: 8px;
            justify-content: center;
        }

        .fs-speed-btn {
            background: rgba(255,255,255,0.1);
            border: 2px solid transparent;
            color: #888;
            padding: 8px 14px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
        }

        .fs-speed-btn.active {
            border-color: #ffa502;
            color: #ffa502;
        }

        /* ========== LANDSCAPE ========== */
        @media (orientation: landscape) and (max-height: 500px) {
            .header { padding: 4px 10px; }
            .header h1 { font-size: 14px; }
            .controls { padding: 6px 10px; }
            .mode-label { display: none; }
            .camera-row { margin-bottom: 6px; }
            .camera-select { padding: 6px 8px; font-size: 12px; }
            .primary-btn { padding: 10px; font-size: 14px; }
            .ctrl-btn { padding: 6px 4px; font-size: 11px; }
            .ctrl-btn .icon { font-size: 16px; }
            .speed-btn { padding: 6px 2px; font-size: 11px; }
            .frame-row { display: none; }
            .progress-wrap { display: none; }
        }

        @media (orientation: landscape) and (max-height: 380px) {
            .header { display: none; }
        }
    </style>
</head>
<body>
    <div class="app-container" id="appContainer">
        <header class="header">
            <h1>Line Review</h1>
            <div class="header-right">
                <div class="recording-indicator" id="recordingIndicator">Ready</div>
                <button class="fullscreen-btn" id="fullscreenBtn">‚õ∂</button>
            </div>
        </header>

        <div class="video-container" id="videoContainer">
            <video id="liveVideo" autoplay playsinline muted></video>
            <canvas id="reviewCanvas"></canvas>

            <!-- Crop overlay -->
            <div class="crop-overlay" id="cropOverlay">
                <div class="crop-region" id="cropRegion">
                    <div class="crop-handle top-left" data-handle="tl"></div>
                    <div class="crop-handle top-right" data-handle="tr"></div>
                    <div class="crop-handle bottom-left" data-handle="bl"></div>
                    <div class="crop-handle bottom-right" data-handle="br"></div>
                    <div class="crop-label" id="cropLabel">Drag to position</div>
                </div>
                <div class="crop-instructions">
                    Position the green box over the line you want to monitor.<br>
                    Drag corners to resize, drag center to move.
                </div>
            </div>

            <div class="overlay-info">
                <div class="info-badge recording" id="modeBadge">‚óè LIVE</div>
            </div>

            <div class="buffer-badge" id="bufferBadge">
                Buffer: <span id="bufferCount">0</span>s
            </div>

            <div class="time-badge" id="timeBadge">00:00.0</div>

            <button class="exit-fullscreen-btn" id="exitFullscreenBtn">‚úï Exit</button>

            <div class="fullscreen-review-controls" id="fsReviewControls">
                <div class="fs-control-row">
                    <button class="fs-btn" id="fsRewindBtn">‚è™ -15s</button>
                    <button class="fs-btn play-btn" id="fsPlayBtn">‚ñ∂Ô∏è</button>
                    <button class="fs-btn" id="fsForwardBtn">+15s ‚è©</button>
                </div>
                <div class="fs-speed-row">
                    <button class="fs-speed-btn" data-speed="0.1">0.1√ó</button>
                    <button class="fs-speed-btn" data-speed="0.25">0.25√ó</button>
                    <button class="fs-speed-btn" data-speed="0.5">0.5√ó</button>
                    <button class="fs-speed-btn active" data-speed="1">1√ó</button>
                </div>
            </div>

            <div class="status-overlay" id="statusOverlay">
                <div class="spinner"></div>
                <div class="status-text" id="statusText">Initializing camera...</div>
            </div>
        </div>

        <div class="controls">
            <div class="mode-label live" id="modeLabel">‚óè RECORDING</div>

            <div class="camera-row">
                <select class="camera-select" id="cameraSelect">
                    <option value="">Loading cameras...</option>
                </select>
                <button class="crop-toggle-btn" id="cropToggleBtn">‚úÇ Crop</button>
            </div>

            <div class="live-controls" id="liveControls">
                <button class="primary-btn review-btn" id="reviewBtn">
                    ‚è™ Review Last Ball
                </button>
            </div>

            <div class="crop-controls" id="cropControls">
                <button class="primary-btn confirm-crop-btn" id="confirmCropBtn">
                    ‚úì Apply Crop Region
                </button>
            </div>

            <div class="review-controls" id="reviewControls">
                <div class="control-grid">
                    <button class="ctrl-btn rewind" id="rewindBtn">
                        <span class="icon">‚è™</span>
                        <span>‚àí15s</span>
                    </button>
                    <button class="ctrl-btn play" id="playBtn">
                        <span class="icon">‚ñ∂Ô∏è</span>
                        <span>Play</span>
                    </button>
                    <button class="ctrl-btn forward" id="forwardBtn">
                        <span class="icon">‚è©</span>
                        <span>+15s</span>
                    </button>
                </div>

                <div class="speed-row">
                    <button class="speed-btn" data-speed="0.1">0.1√ó</button>
                    <button class="speed-btn" data-speed="0.25">0.25√ó</button>
                    <button class="speed-btn" data-speed="0.5">0.5√ó</button>
                    <button class="speed-btn active" data-speed="1">1√ó</button>
                </div>

                <div class="frame-row">
                    <button class="frame-btn" id="framePrev">‚óÄ Prev Frame</button>
                    <button class="frame-btn" id="frameNext">Next Frame ‚ñ∂</button>
                </div>

                <div class="scrubber-wrap">
                    <input type="range" class="scrubber-slider" id="scrubberInput" min="0" max="100" value="0">
                    <div class="progress-time">
                        <span id="currentTime">00:00.0</span>
                        <span id="totalTime">00:00.0</span>
                    </div>
                </div>

                <button class="primary-btn back-btn" id="backBtn">
                    üìπ Back to Live
                </button>
            </div>
        </div>
    </div>

    <script>
        // ============================================
        // CONFIG & STATE
        // ============================================

        const CONFIG = {
            FPS: 15,
            BUFFER_SECONDS: 120,
            CAPTURE_WIDTH: null,
            CAPTURE_HEIGHT: null
        };

        const state = {
            mode: 'live', // 'live', 'crop', 'review'
            stream: null,
            captureCanvas: null,
            captureCtx: null,
            frameBuffer: [],
            maxFrames: 2700,
            isCapturing: false,
            captureAnimationId: null,
            lastCaptureTime: 0,
            isFullscreen: false,

            // Crop state (relative to video, 0-1)
            cropEnabled: false,
            cropRect: { x: 0.1, y: 0.3, width: 0.8, height: 0.4 },
            
            // Video dimensions
            videoWidth: 0,
            videoHeight: 0,

            // Review state
            reviewIndex: 0,
            isPlaying: false,
            playbackSpeed: 1,
            playbackInterval: null
        };

        const el = {
            appContainer: document.getElementById('appContainer'),
            videoContainer: document.getElementById('videoContainer'),
            liveVideo: document.getElementById('liveVideo'),
            reviewCanvas: document.getElementById('reviewCanvas'),
            recordingIndicator: document.getElementById('recordingIndicator'),
            modeBadge: document.getElementById('modeBadge'),
            modeLabel: document.getElementById('modeLabel'),
            bufferBadge: document.getElementById('bufferBadge'),
            bufferCount: document.getElementById('bufferCount'),
            timeBadge: document.getElementById('timeBadge'),
            statusOverlay: document.getElementById('statusOverlay'),
            statusText: document.getElementById('statusText'),
            cameraSelect: document.getElementById('cameraSelect'),
            liveControls: document.getElementById('liveControls'),
            reviewControls: document.getElementById('reviewControls'),
            cropControls: document.getElementById('cropControls'),
            reviewBtn: document.getElementById('reviewBtn'),
            backBtn: document.getElementById('backBtn'),
            rewindBtn: document.getElementById('rewindBtn'),
            playBtn: document.getElementById('playBtn'),
            forwardBtn: document.getElementById('forwardBtn'),
            framePrev: document.getElementById('framePrev'),
            frameNext: document.getElementById('frameNext'),
            currentTime: document.getElementById('currentTime'),
            totalTime: document.getElementById('totalTime'),
            fullscreenBtn: document.getElementById('fullscreenBtn'),
            exitFullscreenBtn: document.getElementById('exitFullscreenBtn'),
            scrubberInput: document.getElementById('scrubberInput'),
            fsReviewControls: document.getElementById('fsReviewControls'),
            fsRewindBtn: document.getElementById('fsRewindBtn'),
            fsPlayBtn: document.getElementById('fsPlayBtn'),
            fsForwardBtn: document.getElementById('fsForwardBtn'),
            cropOverlay: document.getElementById('cropOverlay'),
            cropRegion: document.getElementById('cropRegion'),
            cropLabel: document.getElementById('cropLabel'),
            cropToggleBtn: document.getElementById('cropToggleBtn'),
            confirmCropBtn: document.getElementById('confirmCropBtn')
        };

        // ============================================
        // INITIALIZATION
        // ============================================

        async function init() {
            if (!window.isSecureContext) {
                showError('Requires HTTPS', 'Camera access needs a secure connection.');
                return;
            }

            state.captureCanvas = document.createElement('canvas');
            state.captureCtx = null;

            try {
                showStatus('Requesting camera access...');
                await getCameras();
                await startCamera();
                hideStatus();
                setupListeners();
                setupCropHandlers();
            } catch (err) {
                console.error('Init error:', err);
                showError('Camera Error', 'Could not access camera. Please allow permission and reload.');
            }
        }

        async function getCameras() {
            try {
                let devices = await navigator.mediaDevices.enumerateDevices();
                let cameras = devices.filter(d => d.kind === 'videoinput');
                
                if (cameras.length === 0 || !cameras[0].label) {
                    const tempStream = await navigator.mediaDevices.getUserMedia({ video: true });
                    state.stream = tempStream;
                    el.liveVideo.srcObject = tempStream;
                    devices = await navigator.mediaDevices.enumerateDevices();
                    cameras = devices.filter(d => d.kind === 'videoinput');
                }

                el.cameraSelect.innerHTML = '';
                cameras.forEach((cam, i) => {
                    const opt = document.createElement('option');
                    opt.value = cam.deviceId;
                    opt.textContent = cam.label || `Camera ${i + 1}`;
                    if (cam.label.toLowerCase().includes('back') || cam.label.toLowerCase().includes('rear')) {
                        opt.selected = true;
                    }
                    el.cameraSelect.appendChild(opt);
                });

                if (cameras.length === 0) throw new Error('No cameras found');
            } catch (err) {
                console.error('getCameras error:', err);
                throw err;
            }
        }

        async function startCamera(deviceId) {
            if (state.stream) {
                state.stream.getTracks().forEach(t => t.stop());
                stopCapturing();
            }

            const constraints = {
                video: {
                    width: { ideal: 1920 },
                    height: { ideal: 1080 },
                    frameRate: { ideal: CONFIG.FPS },
                    facingMode: deviceId ? undefined : 'environment'
                },
                audio: false
            };

            if (deviceId) {
                constraints.video.deviceId = { exact: deviceId };
            }

            state.stream = await navigator.mediaDevices.getUserMedia(constraints);
            el.liveVideo.srcObject = state.stream;

            await new Promise(resolve => {
                el.liveVideo.onloadedmetadata = () => {
                    el.liveVideo.play().then(resolve).catch(resolve);
                };
            });

            el.liveVideo.onpause = () => {
                if (state.mode === 'live' && state.stream) {
                    el.liveVideo.play().catch(() => {});
                }
            };

            state.videoWidth = el.liveVideo.videoWidth;
            state.videoHeight = el.liveVideo.videoHeight;
            
            console.log(`Camera resolution: ${state.videoWidth}x${state.videoHeight}`);

            setupCaptureCanvas();
            state.frameBuffer = [];
            startCapturing();
        }

        function setupCaptureCanvas() {
            let captureWidth, captureHeight;

            if (state.cropEnabled) {
                // Calculate crop dimensions in pixels
                const cropPixelWidth = Math.round(state.videoWidth * state.cropRect.width);
                const cropPixelHeight = Math.round(state.videoHeight * state.cropRect.height);
                
                // Scale down if needed, max 480px on longest side
                const maxDim = 480;
                if (cropPixelWidth > cropPixelHeight) {
                    captureWidth = Math.min(cropPixelWidth, maxDim);
                    captureHeight = Math.round(captureWidth * (cropPixelHeight / cropPixelWidth));
                } else {
                    captureHeight = Math.min(cropPixelHeight, maxDim);
                    captureWidth = Math.round(captureHeight * (cropPixelWidth / cropPixelHeight));
                }
            } else {
                // Full frame, scale to 480p
                const maxDim = 480;
                if (state.videoWidth > state.videoHeight) {
                    captureWidth = Math.min(state.videoWidth, maxDim);
                    captureHeight = Math.round(captureWidth * (state.videoHeight / state.videoWidth));
                } else {
                    captureHeight = Math.min(state.videoHeight, maxDim);
                    captureWidth = Math.round(captureHeight * (state.videoWidth / state.videoHeight));
                }
            }

            // Ensure even dimensions
            captureWidth = Math.floor(captureWidth / 2) * 2;
            captureHeight = Math.floor(captureHeight / 2) * 2;

            CONFIG.CAPTURE_WIDTH = captureWidth;
            CONFIG.CAPTURE_HEIGHT = captureHeight;

            state.captureCanvas.width = captureWidth;
            state.captureCanvas.height = captureHeight;
            state.captureCtx = state.captureCanvas.getContext('2d', { willReadFrequently: true });

            el.reviewCanvas.width = captureWidth;
            el.reviewCanvas.height = captureHeight;

            // Calculate max frames
            const bytesPerFrame = captureWidth * captureHeight * 4;
            const targetMemoryMB = 500;
            const maxFramesByMemory = Math.floor((targetMemoryMB * 1024 * 1024) / bytesPerFrame);
            state.maxFrames = Math.min(CONFIG.FPS * CONFIG.BUFFER_SECONDS, maxFramesByMemory);

            const bufferSecs = (state.maxFrames / CONFIG.FPS).toFixed(0);
            console.log(`Capture: ${captureWidth}x${captureHeight}, Buffer: ~${bufferSecs}s`);
            el.cropLabel.textContent = `~${bufferSecs}s buffer`;
        }

        // ============================================
        // CROP HANDLING
        // ============================================

        function enterCropMode() {
            state.mode = 'crop';
            stopCapturing();
            
            el.cropOverlay.classList.add('visible');
            el.liveControls.classList.add('hidden');
            el.cropControls.classList.add('active');
            el.cropToggleBtn.classList.add('active');
            
            el.modeBadge.textContent = '‚úÇ CROP';
            el.modeBadge.classList.remove('recording', 'review');
            el.modeBadge.classList.add('crop-mode');
            
            el.modeLabel.textContent = '‚úÇ SET CROP REGION';
            el.modeLabel.classList.remove('live', 'review');
            el.modeLabel.classList.add('crop');

            updateCropRegionDisplay();
        }

        function exitCropMode(apply = false) {
            if (apply) {
                state.cropEnabled = true;
                state.frameBuffer = []; // Clear buffer when crop changes
                setupCaptureCanvas();
            }

            state.mode = 'live';
            
            el.cropOverlay.classList.remove('visible');
            el.cropControls.classList.remove('active');
            el.liveControls.classList.remove('hidden');
            el.cropToggleBtn.classList.toggle('active', state.cropEnabled);
            
            el.modeBadge.textContent = '‚óè LIVE';
            el.modeBadge.classList.add('recording');
            el.modeBadge.classList.remove('crop-mode', 'review');
            
            el.modeLabel.textContent = '‚óè RECORDING';
            el.modeLabel.classList.add('live');
            el.modeLabel.classList.remove('crop', 'review');

            startCapturing();
        }

        function updateCropRegionDisplay() {
            const container = el.videoContainer;
            const video = el.liveVideo;
            
            // Get video display dimensions
            const containerRect = container.getBoundingClientRect();
            const videoAspect = state.videoWidth / state.videoHeight;
            const containerAspect = containerRect.width / containerRect.height;
            
            let displayWidth, displayHeight, offsetX, offsetY;
            
            if (videoAspect > containerAspect) {
                // Video is wider - letterbox top/bottom
                displayWidth = containerRect.width;
                displayHeight = containerRect.width / videoAspect;
                offsetX = 0;
                offsetY = (containerRect.height - displayHeight) / 2;
            } else {
                // Video is taller - letterbox left/right
                displayHeight = containerRect.height;
                displayWidth = containerRect.height * videoAspect;
                offsetX = (containerRect.width - displayWidth) / 2;
                offsetY = 0;
            }

            // Convert crop rect to screen coordinates
            const screenX = offsetX + state.cropRect.x * displayWidth;
            const screenY = offsetY + state.cropRect.y * displayHeight;
            const screenW = state.cropRect.width * displayWidth;
            const screenH = state.cropRect.height * displayHeight;

            el.cropRegion.style.left = `${screenX}px`;
            el.cropRegion.style.top = `${screenY}px`;
            el.cropRegion.style.width = `${screenW}px`;
            el.cropRegion.style.height = `${screenH}px`;

            // Update buffer estimate
            setupCaptureCanvas();
        }

        function setupCropHandlers() {
            let isDragging = false;
            let dragType = null; // 'move' or 'tl', 'tr', 'bl', 'br'
            let startX, startY;
            let startRect;

            function getEventPos(e) {
                const touch = e.touches ? e.touches[0] : e;
                return { x: touch.clientX, y: touch.clientY };
            }

            function getVideoCoords(screenX, screenY) {
                const container = el.videoContainer;
                const containerRect = container.getBoundingClientRect();
                const videoAspect = state.videoWidth / state.videoHeight;
                const containerAspect = containerRect.width / containerRect.height;
                
                let displayWidth, displayHeight, offsetX, offsetY;
                
                if (videoAspect > containerAspect) {
                    displayWidth = containerRect.width;
                    displayHeight = containerRect.width / videoAspect;
                    offsetX = 0;
                    offsetY = (containerRect.height - displayHeight) / 2;
                } else {
                    displayHeight = containerRect.height;
                    displayWidth = containerRect.height * videoAspect;
                    offsetX = (containerRect.width - displayWidth) / 2;
                    offsetY = 0;
                }

                return {
                    x: (screenX - containerRect.left - offsetX) / displayWidth,
                    y: (screenY - containerRect.top - offsetY) / displayHeight,
                    displayWidth,
                    displayHeight
                };
            }

            function onStart(e) {
                if (state.mode !== 'crop') return;
                e.preventDefault();
                
                const target = e.target;
                const pos = getEventPos(e);
                startX = pos.x;
                startY = pos.y;
                startRect = { ...state.cropRect };

                if (target.classList.contains('crop-handle')) {
                    dragType = target.dataset.handle;
                } else if (target === el.cropRegion || target.classList.contains('crop-label')) {
                    dragType = 'move';
                } else {
                    return;
                }

                isDragging = true;
            }

            function onMove(e) {
                if (!isDragging) return;
                e.preventDefault();

                const pos = getEventPos(e);
                const coords = getVideoCoords(pos.x, pos.y);
                const startCoords = getVideoCoords(startX, startY);
                
                const dx = coords.x - startCoords.x;
                const dy = coords.y - startCoords.y;

                if (dragType === 'move') {
                    state.cropRect.x = Math.max(0, Math.min(1 - startRect.width, startRect.x + dx));
                    state.cropRect.y = Math.max(0, Math.min(1 - startRect.height, startRect.y + dy));
                } else {
                    // Handle resize
                    let newX = startRect.x;
                    let newY = startRect.y;
                    let newW = startRect.width;
                    let newH = startRect.height;

                    if (dragType.includes('l')) {
                        newX = Math.max(0, Math.min(startRect.x + startRect.width - 0.1, startRect.x + dx));
                        newW = startRect.width - (newX - startRect.x);
                    }
                    if (dragType.includes('r')) {
                        newW = Math.max(0.1, Math.min(1 - startRect.x, startRect.width + dx));
                    }
                    if (dragType.includes('t')) {
                        newY = Math.max(0, Math.min(startRect.y + startRect.height - 0.1, startRect.y + dy));
                        newH = startRect.height - (newY - startRect.y);
                    }
                    if (dragType.includes('b')) {
                        newH = Math.max(0.1, Math.min(1 - startRect.y, startRect.height + dy));
                    }

                    state.cropRect = { x: newX, y: newY, width: newW, height: newH };
                }

                updateCropRegionDisplay();
            }

            function onEnd() {
                isDragging = false;
                dragType = null;
            }

            // Mouse events
            el.cropRegion.addEventListener('mousedown', onStart);
            document.addEventListener('mousemove', onMove);
            document.addEventListener('mouseup', onEnd);

            // Touch events
            el.cropRegion.addEventListener('touchstart', onStart, { passive: false });
            document.addEventListener('touchmove', onMove, { passive: false });
            document.addEventListener('touchend', onEnd);

            // Handle resize
            window.addEventListener('resize', () => {
                if (state.mode === 'crop') {
                    updateCropRegionDisplay();
                }
            });
        }

        // ============================================
        // FRAME CAPTURE
        // ============================================

        function startCapturing() {
            if (state.isCapturing) return;

            state.isCapturing = true;
            state.lastCaptureTime = 0;

            el.recordingIndicator.classList.add('active');
            el.recordingIndicator.textContent = 'Recording';

            function captureLoop(timestamp) {
                if (!state.isCapturing) return;

                const intervalMs = 1000 / CONFIG.FPS;
                
                if (timestamp - state.lastCaptureTime >= intervalMs) {
                    captureFrame();
                    state.lastCaptureTime = timestamp;
                }

                state.captureAnimationId = requestAnimationFrame(captureLoop);
            }

            state.captureAnimationId = requestAnimationFrame(captureLoop);
        }

        function stopCapturing() {
            state.isCapturing = false;
            if (state.captureAnimationId) {
                cancelAnimationFrame(state.captureAnimationId);
                state.captureAnimationId = null;
            }
            el.recordingIndicator.classList.remove('active');
            el.recordingIndicator.textContent = 'Paused';
        }

        function captureFrame() {
            try {
                if (!state.stream || !el.liveVideo.videoWidth || el.liveVideo.paused) {
                    if (el.liveVideo.paused && state.stream) {
                        el.liveVideo.play().catch(() => {});
                    }
                    return;
                }

                if (state.cropEnabled) {
                    // Capture cropped region
                    const srcX = Math.round(state.cropRect.x * state.videoWidth);
                    const srcY = Math.round(state.cropRect.y * state.videoHeight);
                    const srcW = Math.round(state.cropRect.width * state.videoWidth);
                    const srcH = Math.round(state.cropRect.height * state.videoHeight);

                    state.captureCtx.drawImage(
                        el.liveVideo,
                        srcX, srcY, srcW, srcH,
                        0, 0, CONFIG.CAPTURE_WIDTH, CONFIG.CAPTURE_HEIGHT
                    );
                } else {
                    // Capture full frame
                    state.captureCtx.drawImage(
                        el.liveVideo,
                        0, 0,
                        CONFIG.CAPTURE_WIDTH,
                        CONFIG.CAPTURE_HEIGHT
                    );
                }

                const imageData = state.captureCtx.getImageData(
                    0, 0,
                    CONFIG.CAPTURE_WIDTH,
                    CONFIG.CAPTURE_HEIGHT
                );

                state.frameBuffer.push(imageData);

                while (state.frameBuffer.length > state.maxFrames) {
                    state.frameBuffer.shift();
                }

                updateBufferDisplay();
            } catch (err) {
                console.error('Capture error:', err);
            }
        }

        function updateBufferDisplay() {
            const seconds = (state.frameBuffer.length / CONFIG.FPS).toFixed(1);
            el.bufferCount.textContent = seconds;
        }

        // ============================================
        // REVIEW MODE
        // ============================================

        function enterReviewMode() {
            if (state.frameBuffer.length < CONFIG.FPS) {
                alert('Not enough footage yet. Wait a few seconds and try again.');
                return;
            }

            stopCapturing();
            state.mode = 'review';
            
            const framesBack = Math.min(CONFIG.FPS * 15, state.frameBuffer.length - 1);
            state.reviewIndex = state.frameBuffer.length - framesBack;
            state.isPlaying = false;
            state.playbackSpeed = 1;

            el.liveVideo.style.display = 'none';
            el.reviewCanvas.style.display = 'block';
            el.liveControls.classList.add('hidden');
            el.reviewControls.classList.add('active');
            el.bufferBadge.style.display = 'none';
            el.appContainer.classList.add('review-active');

            el.modeBadge.textContent = '‚è∏ REVIEW';
            el.modeBadge.classList.remove('recording', 'crop-mode');
            el.modeBadge.classList.add('review');

            el.modeLabel.textContent = '‚è∏ REVIEW MODE';
            el.modeLabel.classList.remove('live', 'crop');
            el.modeLabel.classList.add('review');

            el.totalTime.textContent = formatTime(state.frameBuffer.length / CONFIG.FPS);
            el.scrubberInput.max = state.frameBuffer.length - 1;
            el.scrubberInput.value = state.reviewIndex;

            renderCurrentFrame();
            updatePlayButton();
            updateScrubber();
            updateSpeedButtons();
        }

        function exitReviewMode() {
            stopPlayback();
            state.mode = 'live';

            el.reviewCanvas.style.display = 'none';
            el.liveVideo.style.display = 'block';
            el.reviewControls.classList.remove('active');
            el.liveControls.classList.remove('hidden');
            el.bufferBadge.style.display = 'block';
            el.appContainer.classList.remove('review-active');

            el.modeBadge.textContent = '‚óè LIVE';
            el.modeBadge.classList.add('recording');
            el.modeBadge.classList.remove('review', 'crop-mode');

            el.modeLabel.textContent = '‚óè RECORDING';
            el.modeLabel.classList.add('live');
            el.modeLabel.classList.remove('review', 'crop');

            startCapturing();
        }

        function renderCurrentFrame() {
            state.reviewIndex = Math.max(0, Math.min(state.frameBuffer.length - 1, state.reviewIndex));

            const frame = state.frameBuffer[state.reviewIndex];
            if (!frame) return;

            const ctx = el.reviewCanvas.getContext('2d');
            ctx.putImageData(frame, 0, 0);

            const currentSec = state.reviewIndex / CONFIG.FPS;
            el.currentTime.textContent = formatTime(currentSec);
            el.timeBadge.textContent = formatTime(currentSec);

            updateScrubber();
        }

        // ============================================
        // PLAYBACK CONTROLS
        // ============================================

        function togglePlay() {
            if (state.isPlaying) {
                stopPlayback();
            } else {
                startPlayback();
            }
        }

        function startPlayback() {
            if (state.reviewIndex >= state.frameBuffer.length - 1) {
                state.reviewIndex = 0;
            }

            state.isPlaying = true;
            updatePlayButton();

            const intervalMs = (1000 / CONFIG.FPS) / state.playbackSpeed;

            state.playbackInterval = setInterval(() => {
                state.reviewIndex++;
                if (state.reviewIndex >= state.frameBuffer.length) {
                    stopPlayback();
                    state.reviewIndex = state.frameBuffer.length - 1;
                } else {
                    renderCurrentFrame();
                }
            }, intervalMs);
        }

        function stopPlayback() {
            state.isPlaying = false;
            if (state.playbackInterval) {
                clearInterval(state.playbackInterval);
                state.playbackInterval = null;
            }
            updatePlayButton();
        }

        function seek(seconds) {
            stopPlayback();
            state.reviewIndex += Math.round(seconds * CONFIG.FPS);
            state.reviewIndex = Math.max(0, Math.min(state.frameBuffer.length - 1, state.reviewIndex));
            renderCurrentFrame();
        }

        function stepFrame(direction) {
            stopPlayback();
            state.reviewIndex += direction;
            state.reviewIndex = Math.max(0, Math.min(state.frameBuffer.length - 1, state.reviewIndex));
            renderCurrentFrame();
        }

        function setSpeed(speed) {
            const wasPlaying = state.isPlaying;
            stopPlayback();
            state.playbackSpeed = speed;
            updateSpeedButtons();
            if (wasPlaying) startPlayback();
        }

        function seekToScrubberPosition() {
            stopPlayback();
            state.reviewIndex = parseInt(el.scrubberInput.value);
            renderCurrentFrame();
        }

        // ============================================
        // FULLSCREEN
        // ============================================

        function toggleFullscreen() {
            if (state.isFullscreen) {
                exitFullscreen();
            } else {
                enterFullscreen();
            }
        }

        function enterFullscreen() {
            state.isFullscreen = true;
            el.appContainer.classList.add('fullscreen-mode');

            const elem = el.appContainer;
            if (elem.requestFullscreen) {
                elem.requestFullscreen().catch(() => {});
            } else if (elem.webkitRequestFullscreen) {
                elem.webkitRequestFullscreen();
            }
        }

        function exitFullscreen() {
            state.isFullscreen = false;
            el.appContainer.classList.remove('fullscreen-mode');

            if (document.exitFullscreen) {
                document.exitFullscreen().catch(() => {});
            } else if (document.webkitExitFullscreen) {
                document.webkitExitFullscreen();
            }
        }

        // ============================================
        // UI UPDATES
        // ============================================

        function updatePlayButton() {
            if (state.isPlaying) {
                el.playBtn.innerHTML = '<span class="icon">‚è∏</span><span>Pause</span>';
                el.playBtn.classList.remove('paused');
                el.fsPlayBtn.textContent = '‚è∏';
                el.fsPlayBtn.classList.remove('paused');
            } else {
                el.playBtn.innerHTML = '<span class="icon">‚ñ∂Ô∏è</span><span>Play</span>';
                el.playBtn.classList.add('paused');
                el.fsPlayBtn.textContent = '‚ñ∂Ô∏è';
                el.fsPlayBtn.classList.add('paused');
            }
        }

        function updateScrubber() {
            el.scrubberInput.value = state.reviewIndex;
            const percent = (state.reviewIndex / Math.max(1, state.frameBuffer.length - 1)) * 100;
            el.scrubberInput.style.setProperty('--progress', `${percent}%`);
        }

        function updateSpeedButtons() {
            document.querySelectorAll('.speed-btn, .fs-speed-btn').forEach(btn => {
                btn.classList.toggle('active', parseFloat(btn.dataset.speed) === state.playbackSpeed);
            });
        }

        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            const tenths = Math.floor((seconds % 1) * 10);
            return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}.${tenths}`;
        }

        function showStatus(text) {
            el.statusText.textContent = text;
            el.statusOverlay.classList.remove('hidden');
        }

        function hideStatus() {
            el.statusOverlay.classList.add('hidden');
        }

        function showError(title, message) {
            el.statusOverlay.innerHTML = `<div class="error-box"><h3>${title}</h3><p>${message}</p></div>`;
            el.statusOverlay.classList.remove('hidden');
        }

        // ============================================
        // EVENT LISTENERS
        // ============================================

        function setupListeners() {
            el.cameraSelect.addEventListener('change', async (e) => {
                if (e.target.value) {
                    showStatus('Switching camera...');
                    try {
                        await startCamera(e.target.value);
                        hideStatus();
                    } catch (err) {
                        showError('Camera Error', 'Could not switch camera.');
                    }
                }
            });

            // Crop toggle
            el.cropToggleBtn.addEventListener('click', () => {
                if (state.mode === 'crop') {
                    exitCropMode(false);
                } else if (state.mode === 'live') {
                    enterCropMode();
                }
            });

            el.confirmCropBtn.addEventListener('click', () => {
                exitCropMode(true);
            });

            el.reviewBtn.addEventListener('click', enterReviewMode);
            el.backBtn.addEventListener('click', exitReviewMode);

            el.playBtn.addEventListener('click', togglePlay);
            el.rewindBtn.addEventListener('click', () => seek(-15));
            el.forwardBtn.addEventListener('click', () => seek(15));

            el.framePrev.addEventListener('click', () => stepFrame(-1));
            el.frameNext.addEventListener('click', () => stepFrame(1));

            document.querySelectorAll('.speed-btn').forEach(btn => {
                btn.addEventListener('click', () => setSpeed(parseFloat(btn.dataset.speed)));
            });

            el.scrubberInput.addEventListener('input', seekToScrubberPosition);

            // Fullscreen
            el.fullscreenBtn.addEventListener('click', toggleFullscreen);
            el.exitFullscreenBtn.addEventListener('click', exitFullscreen);

            // Fullscreen review controls
            el.fsPlayBtn.addEventListener('click', togglePlay);
            el.fsRewindBtn.addEventListener('click', () => seek(-15));
            el.fsForwardBtn.addEventListener('click', () => seek(15));

            document.querySelectorAll('.fs-speed-btn').forEach(btn => {
                btn.addEventListener('click', () => setSpeed(parseFloat(btn.dataset.speed)));
            });

            document.addEventListener('fullscreenchange', () => {
                if (!document.fullscreenElement && state.isFullscreen) exitFullscreen();
            });

            document.addEventListener('webkitfullscreenchange', () => {
                if (!document.webkitFullscreenElement && state.isFullscreen) exitFullscreen();
            });

            // Keyboard shortcuts
            document.addEventListener('keydown', (e) => {
                if (state.mode === 'crop') return;
                if (state.mode !== 'review') return;

                switch (e.key) {
                    case ' ': e.preventDefault(); togglePlay(); break;
                    case 'ArrowLeft': e.preventDefault(); seek(-5); break;
                    case 'ArrowRight': e.preventDefault(); seek(5); break;
                    case ',': stepFrame(-1); break;
                    case '.': stepFrame(1); break;
                    case 'f': toggleFullscreen(); break;
                    case 'Escape': if (state.isFullscreen) exitFullscreen(); break;
                }
            });
        }

        // Start
        init();
    </script>
</body>
</html>
